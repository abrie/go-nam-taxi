<!DOCTYPE html>
<html>

<head>
    <style type="text/css">
        #map-container { 
            width: 500px; 
            height: 200px;
        }
        video {
            width: 100%;
        }
        #camera-container {
            width: 500px;
        }
        #hidden-things {
            display: none;
        }
    </style>
</head>

<body>
    <h1>#GoNamTaxi Prototype Client</h1>

    <div>
        <span>Client identifier:</span>
        <span id="client-id">[?]</span>
    </div>

    <img id="out-img" src='' width="200px">

    <div id="map-container">
        waiting for map to load...
    </div>

    <div id="camera-container">
        <video id="camera" autoplay></video> 
    </div>

    <div id="hidden-things">
        <canvas id="camera-canvas"></canvas>
    </div>
    
    <script type="text/javascript" defer>
        var state = {
            websocket: undefined,
            map: undefined,
            polylines: undefined
        }

        var config = {
            google_maps_browser_key: undefined,
            server_websocket_url: 'ws://localhost:9090',
        };

        var ui = {
            map_container: document.getElementById("map-container"),
            client_id: document.getElementById("client-id"),
            update_id: document.getElementById("update-id")
        };

        function handleHello(json) {
            config.google_maps_browser_key = json.google_maps_browser_key;
            ui.client_id.innerHTML = json.clientId;
            loadMapAPI();
        }

        function handleUpdate(json) {
            ui.update_id.innerHTML = json.content;
        }

        function handleSnappedPath(json) {
            function processSnapToRoadResponse(snappedPoints) {
                snappedCoordinates = [];
                placeIdArray = [];
                for (var i = 0; i < snappedPoints.length; i++) {
                    var latlng = new google.maps.LatLng(
                            snappedPoints[i].location.latitude,
                            snappedPoints[i].location.longitude);
                    snappedCoordinates.push(latlng);
                    placeIdArray.push(snappedPoints[i].placeId);
                }

                return snappedCoordinates;
            }

            function drawPolyline(coordinates) {
                var snappedPolyline = new google.maps.Polyline({
                    path: coordinates,
                    strokeColor: 'blue',
                    strokeWeight: 6
                });

                if (state.polylines) {
                    state.polylines.setMap(null);
                }

                snappedPolyline.setMap(state.map.map);
                state.polylines = snappedPolyline;
            }

            var snappedCoordinates = processSnapToRoadResponse(json.content);
            drawPolyline(snappedCoordinates);

        }

        function connectToServer() {
            var ws = new WebSocket(config.server_websocket_url);

            var handlers = {
                0:handleHello,
                1:handleUpdate,
                2:handleSnappedPath,
            }

            ws.onmessage = function(event) {
                var json = JSON.parse(event.data);
                handlers[json.type](json);
            };

            return ws;
        }

        function buildRequest(baseUrl, params) {
            var result = undefined;
            for (var name in params) {
                result = result === undefined ? baseUrl : result.concat("&");
                result = result.concat(name + "=" + params[name]);
            }

            return result;
        }

        function getApiKey() {
            return config.google_maps_browser_key;
        }

        function loadMapAPI() {
            var baseUrl = "https://maps.googleapis.com/maps/api/js?";
            var params = {
                'key': getApiKey(),
                'callback': "onMapAPILoaded",
                'libraries': ['drawing'].join(',')
            }
            
            var script = document.createElement('script');
            script.type = 'text/javascript';
            script.src = buildRequest(baseUrl, params);

            document.body.appendChild(script);
        }

        function onMapAPILoaded() {
            var map = createMap();
            var draw = createDrawManager();

            draw.setMap(map);
            draw.addListener('polylinecomplete', function(poly) {
                function pathToString(path) {
                    var pathValues = [];
                    for (var i = 0; i < path.getLength(); i++) {
                        pathValues.push(path.getAt(i).toUrlValue());
                    }
                    return pathValues.join('|');
                }

                state.websocket.send(JSON.stringify({
                    clientId: state.clientId,
                    path: pathToString(poly.getPath())
                }));

                poly.setMap(null);
            });

            state.map = {
                map: map,
                draw: draw
            }
        }

        function createMap() {
            return new google.maps.Map(ui.map_container, {
                center: {lat: -22.5700, lng:17.0836},
                zoom: 16 
            });
        }

        function createDrawManager() {
            // See example at: https://developers.google.com/maps/documentation/roads/snap
            // Enables the polyline drawing control. Click on the map to start drawing a
            // polyline. Each click will add a new vertice. Double-click to stop drawing.
            return new google.maps.drawing.DrawingManager({
                drawingMode: google.maps.drawing.OverlayType.POLYLINE,
                drawingControl: true,
                drawingControlOptions: {
                    position: google.maps.ControlPosition.TOP_CENTER,
                    drawingModes: [
                        google.maps.drawing.OverlayType.POLYLINE
                    ]
                },
                polylineOptions: {
                    strokeColor: '#696969',
                    strokeWeight: 2
                }
            });
        }

        function findGetUserMediaFunction() {
            var tryList = [
                navigator.getUserMedia,
                navigator.webkitGetUserMedia, 
                navigator.mozGetUserMedia,
                navigator.msGetUserMedia];

            var foundList = tryList.filter(function(e) {
                return e !== undefined;
            })

            if (foundList.length > 0) {
                if (foundList.length > 1) {
                    console.log("WIERD: More than one getUsermedia function found.");
                }
                return foundList[0].bind(navigator);
            }
            else {
                console.log("ERROR: No getUserMedia function found.");
                return undefined;
            }

        }

        function onUserMediaError(e) {
            console.log("getUserMediaError:",e);
        }

        function onUserMediaSuccess(mediaStream) {
            var cameraVideo = document.getElementById('camera');
            cameraVideo.src = window.URL.createObjectURL(mediaStream);
            cameraVideo.onloadedmetadata = function(e) {
                var cameraCanvasContext = getCameraCanvasContext(
                        cameraVideo.videoWidth,
                        cameraVideo.videoHeight);
                captureCameraFrame(cameraVideo, cameraCanvasContext);
            };
        }

        function getCameraCanvasContext(width, height) {
            var canvasElement = document.getElementById('camera-canvas');
            canvasElement.width = width;
            canvasElement.height = height;
            return canvasElement.getContext('2d');
        }

        function captureCameraFrame(video, canvasContext) {
            console.log(video, canvasContext, canvasContext.canvas);
            canvasContext.drawImage(video, 0, 0);
            // "image/webp" works in Chrome, others will fall back to image/png.
            document.getElementById('out-img').src = 
                canvasContext.canvas.toDataURL('image/webp');
        }

        var getUserMedia = findGetUserMediaFunction();

        getUserMedia({video: true, audio: false}, onUserMediaSuccess, onUserMediaError);

        state.websocket = connectToServer();

    </script>
</body>

</html>
